---
layout: documentation
title: ReactiveX - FlatMap operator
id: flatMap
---

<ol class="breadcrumb">
  <li><a href="{{ site.url }}/documentation/operators.html">Operators</a></li>
  <li><a href="{{ site.url }}/documentation/operators.html#transforming">Transforming</a></li>
  <li class="active">FlatMap</li>
</ol>

<h1>FlatMap</h1>
<h3>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</h3>

<figure>
 <img src="images/flatMap.c.png" style="width:100%;" alt="FlatMap" />
 <figcaption><p>
  The <span class="operator">FlatMap</span> operator transforms an Observable by applying a function
  that you specify to each item emitted by the source Observable, where that function returns an
  Observable that itself emits items. <span class="operator">FlatMap</span> then merges the emissions
  of these resulting Observables, emitting these merged results as its own sequence.
 </p><p>
  This method is useful, for example, when you have an Observable that emits a series of items that
  themselves have Observable members or are in other ways transformable into Observables, so that you
  can create a new Observable that emits the complete collection of items emitted by the
  sub-Observables of these items.
 </p><p>
  Note that <span class="operator">FlatMap</span> <em>merges</em> the emissions of these Observables,
  so that they may interleave.
 </p><p>
  In several of the language-specific implementations there is also an operator that does
  <em>not</em> interleave the emissions from the transformed Observables, but instead emits these
  emissions in strict order, often called <span class="operator">ConcatMap</span> or something
  similar.
 </p></figcaption>
</figure>

<h4>See Also</h4>
<ul>
 <li><a href="map.html"><span class="operator">Map</span></a></li>
 <li><a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/"><cite>Grokking RxJava</cite>: Operator, Operator</a> by Dan Lew</li>
 <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#SelectMany"><cite>Introduction to Rx</cite>: SelectMany</a></li>
 <li><a href="https://jkschneider.github.io/blog/2014/recursive-observables-with-rxjava.html"><cite>Recurseive Observables with RxJava</cite></a> by Jon Schneider</li>
 <li><a href="http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/">RxJava Observable transformation: concatMap() vs. flatMap()</cite></a> by Fernando Cejas</li>
</ul>

<h2>Language-Specific Information:</h2>

<div class="panel-group operators-by-language" id="accordion" role="tablist" aria-multiselectable="true">

  {% lang_operator RxClojure flatmap mapcat %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator flat_map %}

  {% lang_operator RxCpp concat_map flat_map %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxGroovy concatMap flatMap flatMapIterable StringObservable.split switchMap %}
    <figure class="variant">
     <img src="images/mergeMap.png" style="width:100%;" alt="flatMap" />
     <figcaption><p>
      RxGroovy implements the <code>flatMap</code> operator.
     </p>
     <h4>Sample Code</h4>
     <div class="code groovy"><pre>
// this closure is an Observable that emits three numbers
numbers   = Observable.from([1, 2, 3]);
// this closure is an Observable that emits two numbers based on what number it is passed
multiples = { n -> Observable.from([ n*2, n*3 ]) };

numbers.flatMap(multiples).subscribe(
  { println(it); },                          // onNext
  { println("Error: " + it.getMessage()); }, // onError
  { println("Sequence complete"); }          // onCompleted
);</pre></div>
     <div class="output"><pre>
2
3
4
6
6
9
Sequence complete</pre></div>
     <p>
      Note that if any of the individual Observables mapped to the items from the source Observable
      by <code>flatMap</code> aborts by invoking <code>onError</code>, the Observable produced by
      <code>flatMap</code> will itself immediately abort and invoke <code>onError</code>.
     </p><p>
      A version of this variant of the operator (still in Beta as of this writing) takes an additional
      <code>int</code> parameter. This parameter sets the maximum number of concurrent subscriptions
      that <code>flatMap</code> will attempt to have to the Observables that the items emitted by the source
      Observable map to. When it reaches this maximum number, it will wait for one of those Observables to
      terminate before subscribing to another.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1)"><code>flatMap(Func1)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20int)"><code>flatMap(Func1,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/mergeMap.nce.png" style="width:100%;" alt="flatMap" />
     <figcaption><p>
      Another version of <code>flatMap</code> creates (and flattens) a new Observable for each item
      <em>and notification</em> from the source Observable.
     </p><p>
      A version of this variant of the operator (still in Beta as of this writing) takes an additional
      <code>int</code> parameter. This parameter sets the maximum number of concurrent subscriptions
      that <code>flatMap</code> will attempt to have to the Observables that the items emitted by the source
      Observable map to. When it reaches this maximum number, it will wait for one of those Observables to
      terminate before subscribing to another.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0)"><code>flatMap(Func1,Func1,Func0)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20int)"><code>flatMap(Func1,Func1,Func0,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/mergeMap.r.png" style="width:100%;" alt="flatMap" />
     <figcaption><p>
      Another version combines items from the source Observable with the Observable triggered by
      those source items, and emits these combinations.
     </p><p>
      A version of this variant of the operator (still in Beta as of this writing) takes an additional
      <code>int</code> parameter. This parameter sets the maximum number of concurrent subscriptions
      that <code>flatMap</code> will attempt to have to the Observables that the items emitted by the source
      Observable map to. When it reaches this maximum number, it will wait for one of those Observables to
      terminate before subscribing to another.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2)"><code>flatMap(Func1,Func2)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2,%20int)"><code>flatMap(Func1,Func2,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/mergeMapIterable.png" style="width:100%;" alt="flatMapIterable" />
     <figcaption><p>
      The <code>flatMapIterable</code> variants pair up source items and generated
      <code>Iterable</code>s rather than source items and generated Observables, but otherwise work
      in much the same way.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1)"><code>flatMapIterable(Func1)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1,%20rx.functions.Func2)"><code>flatMapIterable(Func1,Func2)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/concatMap.png" style="width:100%;" alt="concatMap" />
     <figcaption><p>
      There is also a <code>concatMap</code> operator, which is like the simpler version of the
      <code>flatMap</code> operator, but it concatenates rather than merges the resulting
      Observables in order to generate its own sequence.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)"><code>concatMap(Func1)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/switchMap.png" style="width:100%;" alt="switchMap" />
     <figcaption><p>
      RxGroovy also implements the <code>switchMap</code> operator. It behaves much like
      <code>flatMap</code>, except that whenever a new item is emitted by the source Observable, it
      will unsubscribe to and stop mirroring the Observable that was generated from the
      previously-emitted item, and begin only mirroring the current one.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchMap(rx.functions.Func1)"><code>switchMap(Func1)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/St.split.png" style="width:100%;" alt="split" />
     <figcaption><p>
      In the distinct <code>StringObservable</code> class (not part of RxGroovy by default) there is also a
      <code>split</code> operator that converts an Observable of Strings into an Observable of Strings that
      treats the source sequence as a stream and splits it on a specified regex boundary, then merges the
      results of this split.
     </p>
     <h4>See Also</h4>
     <ul>
      <li><a href="http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html">Aligning packets with JSON documents</a> with the <code>split</code> operator</li>
     </ul>
     </figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJava concatMap flatMap flatMapIterable StringObervable.split switchMap %}
    <figure class="variant">
     <img src="images/mergeMap.png" style="width:100%;" alt="flatMap" />
     <figcaption><p>
      RxJava implements the <code>flatMap</code> operator.
     </p><p>
      Note that if any of the individual Observables mapped to the items from the source Observable
      by <code>flatMap</code> aborts by invoking <code>onError</code>, the Observable produced by
      <code>flatMap</code> will itself immediately abort and invoke <code>onError</code>.
     </p><p>
      A version of this variant of the operator (still in Beta as of this writing) takes an additional
      <code>int</code> parameter. This parameter sets the maximum number of concurrent subscriptions
      that <code>flatMap</code> will attempt to have to the Observables that the items emitted by the source
      Observable map to. When it reaches this maximum number, it will wait for one of those Observables to
      terminate before subscribing to another.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1)"><code>flatMap(Func1)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20int)"><code>flatMap(Func1,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/mergeMap.nce.png" style="width:100%;" alt="flatMap" />
     <figcaption><p>
      Another version of <code>flatMap</code> creates (and flattens) a new Observable for each item
      <em>and notification</em> from the source Observable.
     </p><p>
      A version of this variant of the operator (still in Beta as of this writing) takes an additional
      <code>int</code> parameter. This parameter sets the maximum number of concurrent subscriptions
      that <code>flatMap</code> will attempt to have to the Observables that the items emitted by the source
      Observable map to. When it reaches this maximum number, it will wait for one of those Observables to
      terminate before subscribing to another.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0)"><code>flatMap(Func1,Func1,Func0)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20int)"><code>flatMap(Func1,Func1,Func0,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/mergeMap.r.png" style="width:100%;" alt="flatMap" />
     <figcaption><p>
      Another version combines items from the source Observable with the Observable triggered by
      those source items, and emits these combinations.
     </p><p>
      A version of this variant of the operator (still in Beta as of this writing) takes an additional
      <code>int</code> parameter. This parameter sets the maximum number of concurrent subscriptions
      that <code>flatMap</code> will attempt to have to the Observables that the items emitted by the source
      Observable map to. When it reaches this maximum number, it will wait for one of those Observables to
      terminate before subscribing to another.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2)"><code>flatMap(Func1,Func2)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2,%20int)"><code>flatMap(Func1,Func2,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/mergeMapIterable.png" style="width:100%;" alt="flatMapIterable" />
     <figcaption><p>
      The <code>flatMapIterable</code> variants pair up source items and generated
      <code>Iterable</code>s rather than source items and generated Observables, but otherwise work
      in much the same way.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1)"><code>flatMapIterable(Func1)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1,%20rx.functions.Func2)"><code>flatMapIterable(Func1,Func2)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/concatMap.png" style="width:100%;" alt="concatMap" />
     <figcaption><p>
      There is also a <code>concatMap</code> operator, which is like the simpler version of the
      <code>flatMap</code> operator, but it concatenates rather than merges the resulting
      Observables in order to generate its own sequence.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)"><code>concatMap(Func1)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/switchMap.png" style="width:100%;" alt="switchMap" />
     <figcaption><p>
      RxJava also implements the <code>switchMap</code> operator. It behaves much like
      <code>flatMap</code>, except that whenever a new item is emitted by the source Observable, it
      will unsubscribe to and stop mirroring the Observable that was generated from the
      previously-emitted item, and begin only mirroring the current one.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchMap(rx.functions.Func1)"><code>switchMap(Func1)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/St.split.png" style="width:100%;" alt="split" />
     <figcaption><p>
      In the distinct <code>StringObservable</code> class (not part of RxJava by default) there is also a
      <code>split</code> operator that converts an Observable of Strings into an Observable of Strings that
      treats the source sequence as a stream and splits it on a specified regex boundary, then merges the
      results of this split.
     </p></figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJS flatMap mergeMap mergeMapTo concatMap concatMapTo switchMap switchMapTo exhaustMap %}
    <p>
     RxJS has a wealth of operators that perform <span class="operator">FlatMap</span>-like operations. In RxJS, the functions that transform items emitted by the source Observable into Observables typically take as parameters both the item and the index of the item in the Observable sequence.
    </p>
    <figure class="variant">
     <h4><code>mergeMap(project, resultSelector)</code></h4>
     <img src="images/flatMap.png" style="width:100%;" alt="mergeMap" />
     <figcaption><p>
      RxJS implements the basic <code>flatMap</code> operator with the alias <code>mergeMap</code>. It has a variant that allows you to apply a transformative function (an optional second parameter to <code>flatMap</code>) to the items emitted by the Observables generated for each item in the source Observable, before
      merging and emitting those items.
     </p><p>
      &ldquo;<code>flatMap</code>&rdquo; is an alias for <code>mergeMap</code>.
     </p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var source = Rx.Observable
  .interval(1000)
  .take(3)
  .mergeMap(x => Rx.Observable.range(x, 3));

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div><div class="output"><pre>
Next: 0
Next: 1
Next: 2
Next: 1
Next: 2
Next: 3
Next: 2
Next: 3
Next: 4
Completed</pre></div>
    </figure>
    <figure class="variant">
     <h4><code>mergeMapTo(observable, resultSelector)</code></h4>
     <img src="images/flatMap.png" style="width:100%;" alt="mergeMapTo" />
     <figcaption><p>
      Operator <code>mergeMapTo</code> is like <code>mergeMap</code>, but always maps each
      source item to the same resulting inner Observable. For cases where your <code>mergeMap</code> projection function would return always the same constant, use <code>mergeMapTo</code> instead.
     </p><p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var source = Rx.Observable
  .interval(1000)
  .take(3)
  .mergeMapTo(Rx.Observable.range(0, 3));

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div><div class="output"><pre>
Next: 0
Next: 1
Next: 2
Next: 0
Next: 1
Next: 2
Next: 0
Next: 1
Next: 2
Completed</pre></div>
    </figure>
    <figure class="variant">
     <h4><code>concatMap(project, resultSelector)</code></h4>
     <img src="images/concatMap.png" style="width:100%;" alt="concatMap" />
     <figcaption><p>
      There is also a <code>concatMap</code> operator, which is like the <code>mergeMap</code>
      operator, but it concatenates rather than merges the resulting Observables in order to
      generate its own result Observable.
     </p>
     </figcaption>
     <div class="code javascript"><pre>
var source = Rx.Observable.range(0, 3)
  .concatMap(x => Rx.Observable.range(x, 3));

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div><div class="output"><pre>
Next: 0
Next: 1
Next: 2
Next: 1
Next: 2
Next: 3
Next: 2
Next: 3
Next: 4
Completed</pre></div>
    </figure>
    <figure class="variant">
     <h4><code>concatMapTo(observable, resultSelector)</code></h4>
     <img src="images/concatMap.png" style="width:100%;" alt="concatMapTo" />
     <figcaption><p>
      Operator <code>concatMapTo</code> is like <code>concatMap</code>, but always maps each
      source item to the same resulting inner Observable. For cases where your <code>concatMap</code> projection function would return always the same constant, use <code>concatMapTo</code> instead.
     </p><p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var source = Rx.Observable.range(0, 3)
  .concatMapTo(Rx.Observable.range(0, 3));

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div><div class="output"><pre>
Next: 0
Next: 1
Next: 2
Next: 0
Next: 1
Next: 2
Next: 0
Next: 1
Next: 2
Completed</pre></div>
    </figure>
    <figure class="variant">
     <h4><code>switchMap(project, resultSelector)</code></h4>
     <img src="images/switchMap.png" style="width:100%;" alt="switchMap" />
     <figcaption><p>
      The <code>switchMap</code> operator behaves much like the standard <span class="operator">mergeMap</span> operator, except that whenever a new item is emitted
      by the source Observable, it will unsubscribe to and stop mirroring the Observable that was generated from the previously-emitted item, and begin only mirroring the current one.
     </p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var source = Rx.Observable
  .interval(120)
  .take(3)
  .switchMap(x => Rx.Observable.interval(50).take(3));

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div><div class="output"><pre>
Next: 0
Next: 1
Next: 0
Next: 1
Next: 0
Next: 1
Next: 2
Completed</pre></div>
     </figcaption>
    </figure>
    <figure class="variant">
     <h4><code>switchMapTo(observable, resultSelector)</code></h4>
     <img src="images/switchMap.png" style="width:100%;" alt="switchMapTo" />
     <figcaption><p>
      Operator <code>switchMapTo</code> is like <code>switchMap</code>, but always maps each
      source item to the same resulting inner Observable. For cases where your <code>switchMap</code> projection function would return always the same constant, use <code>switchMapTo</code> instead.
     </p><p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var source = Rx.Observable
  .interval(120)
  .take(3)
  .switchMapTo(Rx.Observable.interval(50).take(3));

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div><div class="output"><pre>
Next: 0
Next: 1
Next: 0
Next: 1
Next: 0
Next: 1
Next: 2
Completed</pre></div>
    </figure>
    <figure class="variant">
     <h4><code>exhaustMap(project, resultSelector)</code></h4>
     <figcaption><p>
      The <code>exhaustMap</code> operator behaves much like the standard <span class="operator">mergeMap</span> operator, except that whenever a new item is emitted
      by the source Observable, it will subscribe and mirror it only if the previous inner Observable has already completed, otherwise it drops the new item.
     </p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var source = Rx.Observable
  .interval(120)
  .take(3)
  .exhaustMap(x => Rx.Observable.interval(50).take(3));

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div><div class="output"><pre>
Next: 0
Next: 1
Next: 2
Next: 0
Next: 1
Next: 2
Completed</pre></div>
     </figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxKotlin concatMap flatMap flatMapIterable switchMap %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator Rx.NET ManySelect SelectMany %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
    <h4>See Also</h4>
    <ul>
     <li><a href="https://social.msdn.microsoft.com/Forums/en-US/e70fe8b6-6d9d-486a-a8d0-c1bc66551ded/what-does-the-new-manyselect-operator-do?forum=rx"><cite>Microsoft Developer Network</cite>: &ldquo;What does the new ManySelect operator do?&rdquo;</a></li>
    </ul>
  {% endlang_operator %}

  {% lang_operator RxPY concat_all expand flat_map for_in many_select select_many select_switch %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator Rx.rb flat_map flat_map_with_index %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxScala concatMap flatMap flatMapIterable flatMapIterableWith flatMapWith switchMap %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxSwift flatMap flatMapWithIndex flatMapFirst flatMapLatest %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

</div>
