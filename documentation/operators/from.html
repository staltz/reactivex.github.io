---
layout: documentation
title: ReactiveX - From operator
id: from
---

<ol class="breadcrumb">
  <li><a href="{{ site.url }}/documentation/operators.html">Operators</a></li>
  <li><a href="{{ site.url }}/documentation/operators.html#creating">Creating</a></li>
  <li class="active">From</li>
</ol>

<h1>From</h1>
<h3>convert various other objects and data types into Observables</h3>

<figure>
 <img src="images/from.c.png" style="width:100%;" alt="From" />
 <figcaption><p>
  When you work with Observables, it can be more convenient if all of the data you mean to work with
  can be represented as Observables, rather than as a mixture of Observables and other types. This
  allows you to use a single set of operators to govern the entire lifespan of the data stream.
 </p><p>
  Iterables, for example, can be thought of as a sort of synchronous Observable; Futures, as a sort
  of Observable that always emits only a single item. By explicitly converting such objects to
  Observables, you allow them to interact as peers with other Observables.
 </p><p>
  For this reason, most ReactiveX implementations have methods that allow you to convert
  certain language-specific objects and data structures into Observables.
 </p></figcaption>
</figure>

<h2>See Also</h2>
<ul>
 <li><a href="just.html"><span class="operator">Just</span></a></li>
 <li><a href="start.html"><span class="operator">Start</span></a></li>
 <li><a href="http://rxwiki.wikidot.com/101samples#toc5"><cite>101 Rx Samples</cite>: Observation Operators</a></li>
 <li><a href="https://www.youtube.com/watch?v=sDqrlNprY24">RxJava Tutorial 03: Observable from, just, &amp; create methods</a></li>
</ul>

<h2>Language-Specific Information:</h2>

<div class="panel-group operators-by-language" id="accordion" role="tablist" aria-multiselectable="true">

  {% lang_operator RxClojure seq %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxCpp from %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxGroovy decode from fromAction fromCallable fromFunc0 fromRunnable runAsync %}
    <figure class="variant">
     <img src="images/from.Future.png" style="width:100%;" alt="from" />
     <figcaption><p>
      In RxGroovy, the <code>from</code> operator can convert a Future, an Iterable, or an Array.
      In the case of an Iterable or an Array, the resulting Observable will emit each item contained
      in the Iterable or Array.
     </p><p>
      In the case of a Future, it will emit the single result of the <code>get</code> call. You may
      optionally pass the version of <code>from</code> that accepts a future two additional
      parameters indicating a timeout span and the units of time that span is denominated in. The
      resulting Observable will terminate with an error if that span of time passes before the
      Future responds with a value.
     </p><p>
      <code>from</code> does not by default operate on any particular <a href="../scheduler.html">Scheduler</a>,
      however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and
      it will use that Scheduler to govern the Future.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(T%5B%5D)"><code>from(array)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.lang.Iterable)"><code>from(Iterable)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future)"><code>from(Future)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20rx.Scheduler)"><code>from(Future,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20long,%20java.util.concurrent.TimeUnit)"><code>from(Future,timout,timeUnit)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/fromFunc0.png" style="width:100%;" alt="fromFunc0" />
     <figcaption><p>
      In addition, in the <code>RxJavaAsyncUtil</code> package, you have available to you the
      following operators that convert actions, callables, functions, and runnables into
      Observables that emit the results of those things:
     </p>
     <ul>
      <li><code>fromAction</code></li>
      <li><code>fromCallable</code></li>
      <li><code>fromFunc0</code></li>
      <li><code>fromRunnable</code></li>
     </ul>
     <p>
      See the <a href="start.html"><span class="operator">Start</span></a> operator for more
      information about those operators.
     </p>
     </figcaption>
    </figure>
    <figure class="variant">
     <img src="images/St.from.png" style="width:100%;" alt="from" />
     <figcaption><p>
      Note that there is also a <code>from</code> operator that is a method of the optional
      <code>StringObservable</code> class. It converts a stream of characters or a
      <code>Reader</code> into an Observable that emits byte arrays or Strings.
     </p></figcaption>
    </figure>
    <p>
     In the separate <code>RxJavaAsyncUtil</code> package, which is not included by default with RxGroovy, there
     is also a <code>runAsync</code> function. Pass <code>runAsync</code> an <code>Action</code> and a
     <a href="../scheduler.html"><code>Scheduler</code></a>, and it will return a
     <code>StoppableObservable</code> that uses the specified <code>Action</code> to generate items that it
     emits.
    </p><p>
     The <code>Action</code> accepts an <code>Observer</code> and a <code>Subscription</code>. It uses the
     <code>Subscription</code> to check for the <code>isUnsubscribed</code> condition, upon which it will stop
     emitting items. You can also manually stop a <code>StoppableObservable</code> at any time by calling its
     <code>unsubscribe</code> method (which will also unsubscribe the <code>Subscription</code> you have
     associated with the <code>StoppableObservable</code>).
    </p><p>
     Because <code>runAsync</code> immediately invokes the <code>Action</code> and begins emitting the items, it
     is possible that some items may be lost in the interval between when you establish the
     <code>StoppableObservable</code> with this method and when your <code>Observer</code> is ready to receive
     items. If this is a problem, you can use the variant of <code>runAsync</code> that also accepts a
     <a href="../subject.html"><code>Subject</code></a> and pass a <code>ReplaySubject</code> with which you can
     retrieve the otherwise-missing items.
    </p>
    <figure>
     <img src="images/St.decode.png" style="width:100%;" alt="decode" />
     <figcaption><p>
      The <code>StringObservable</code> class, which is not a default part of RxGroovy, also includes the
      <code>decode</code> operator which converts a stream of multibyte characters into an Observable that
      emits byte arrays that respect the character boundaries.
     </p></figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJava decode from fromAction fromCallable fromFunc0 fromRunnable runAsync %}
    <figure class="variant">
     <img src="images/from.Future.png" style="width:100%;" alt="from" />
     <figcaption><p>
      In RxJava, the <code>from</code> operator can convert a Future, an Iterable, or an Array.
      In the case of an Iterable or an Array, the resulting Observable will emit each item contained
      in the Iterable or Array.
     </p>
     <h4>Sample Code</h4>
     <div class="code java"><pre>
Integer[] items = { 0, 1, 2, 3, 4, 5 };
Observable myObservable = Observable.from(items);

myObservable.subscribe(
    new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer item) {
            System.out.println(item);
        }
    },
    new Action1&lt;Throwable&gt;() {
        @Override
        public void call(Throwable error) {
            System.out.println("Error encountered: " + error.getMessage());
        }
    },
    new Action0() {
        @Override
        public void call() {
            System.out.println("Sequence complete");
        }
    }
);
</pre></div>
     <div class="output"><pre>
0
1
2
3
4
5
Sequence complete</pre></div>
     <p>
      In the case of a Future, it will emit the single result of the <code>get</code> call. You may
      optionally pass the version of <code>from</code> that accepts a future two additional
      parameters indicating a timeout span and the units of time that span is denominated in. The
      resulting Observable will terminate with an error if that span of time passes before the
      Future responds with a value.
     </p><p>
      <code>from</code> does not by default operate on any particular <a href="../scheduler.html">Scheduler</a>,
      however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and
      it will use that Scheduler to govern the Future.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(T%5B%5D)"><code>from(array)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.lang.Iterable)"><code>from(Iterable)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future)"><code>from(Future)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20rx.Scheduler)"><code>from(Future,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20long,%20java.util.concurrent.TimeUnit)"><code>from(Future,timout,timeUnit)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/fromFunc0.png" style="width:100%;" alt="fromFunc0" />
     <figcaption><p>
      In addition, in the <code>RxJavaAsyncUtil</code> package, you have available to you the
      following operators that convert actions, callables, functions, and runnables into
      Observables that emit the results of those things:
     </p>
     <ul>
      <li><code>fromAction</code></li>
      <li><code>fromCallable</code></li>
      <li><code>fromFunc0</code></li>
      <li><code>fromRunnable</code></li>
     </ul>
     <p>
      See the <a href="start.html"><span class="operator">Start</span></a> operator for more
      information about those operators.
     </p>
     </figcaption>
    </figure>
    <figure class="variant">
     <img src="images/St.from.png" style="width:100%;" alt="from" />
     <figcaption><p>
      Note that there is also a <code>from</code> operator that is a method of the optional
      <code>StringObservable</code> class. It converts a stream of characters or a
      <code>Reader</code> into an Observable that emits byte arrays or Strings.
     </p></figcaption>
    </figure>
    <p>
     In the separate <code>RxJavaAsyncUtil</code> package, which is not included by default with RxJava, there
     is also a <code>runAsync</code> function. Pass <code>runAsync</code> an <code>Action</code> and a
     <a href="../scheduler.html"><code>Scheduler</code></a>, and it will return a
     <code>StoppableObservable</code> that uses the specified <code>Action</code> to generate items that it
     emits.
    </p><p>
     The <code>Action</code> accepts an <code>Observer</code> and a <code>Subscription</code>. It uses the
     <code>Subscription</code> to check for the <code>isUnsubscribed</code> condition, upon which it will stop
     emitting items. You can also manually stop a <code>StoppableObservable</code> at any time by calling its
     <code>unsubscribe</code> method (which will also unsubscribe the <code>Subscription</code> you have
     associated with the <code>StoppableObservable</code>).
    </p><p>
     Because <code>runAsync</code> immediately invokes the <code>Action</code> and begins emitting the items, it
     is possible that some items may be lost in the interval between when you establish the
     <code>StoppableObservable</code> with this method and when your <code>Observer</code> is ready to receive
     items. If this is a problem, you can use the variant of <code>runAsync</code> that also accepts a
     <a href="../subject.html"><code>Subject</code></a> and pass a <code>ReplaySubject</code> with which you can
     retrieve the otherwise-missing items.
    </p>
    <figure>
     <img src="images/St.decode.png" style="width:100%;" alt="decode" />
     <figcaption><p>
      The <code>StringObservable</code> class, which is not a default part of RxGroovy, also includes the
      <code>decode</code> operator which converts a stream of multibyte characters into an Observable that
      emits byte arrays that respect the character boundaries.
     </p></figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJS from fromArray fromEvent fromEventPattern bindCallback bindNodeCallback fromPromise of %}
    <p>
     There are several specialized <span class="operator">From</span> variants in RxJS:
    </p>

    <figure class="variant">
     <img src="images/from.png" style="width:100%;" alt="from" />
     <figcaption><p>
      In RxJS, the <code>from</code> operator converts an array-like or iterable object or a promise
      into an Observable that emits the items in that array or iterable. A String, in this context,
      is treated as an array of characters.
     </p><p>
      This operator also takes an additional optional parameter:
     </p>
     <ol start="2">
      <li>a <a href="../scheduler.html">Scheduler</a> on which this operator should operate</li>
     </ol>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
// Array-like object (arguments) to Observable
function f() {
  return Rx.Observable.from(arguments);
}

f(1, 2, 3).subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: 1
Next: 2
Next: 3
Completed</pre></div>
     <div class="code javascript"><pre>
var promise = Promise.resolve(42);
var source = Rx.Observable.from(Promise.resolve(42));

source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: 42
Completed</pre></div>
     <div class="code javascript"><pre>
// String
Rx.Observable.from("foo").subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: f
Next: o
Next: o
Completed</pre></div>
     </figcaption>
    </figure>

    <figure class="variant">
     <img src="images/fromArray.png" style="width:100%;" alt="from" />
     <figcaption><p>
       <code>fromArray</code> is a specialized version of <code>from</code> which only accepts
       an array as argument.
     </p>
     <div class="code javascript"><pre>
var source = Rx.Observable.fromArray([1, 2, 3])

source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: 1
Next: 2
Next: 3
Completed</pre></div>
     </figcaption>
    </figure>

    <figure class="variant">
     <img src="images/bindCallback.png" style="width:100%;" alt="bindCallback" />
     <figcaption><p>
      The <code>bindCallback</code> operator converts a callback to an Observable. It takes a source
      function as parameter and returns an Observable factory function. When the Observable (returned
      from the factory) is subscribed, the source function is called, and the callback result is
      emitted on the Observable, as the only emission.
     </p><p>
      This operator also takes two additional, optional parameters:
     </p>
     <ol start="2">
      <li>a tranforming function that takes the return value of the callback function as input and returns an item to be emitted by the resulting Observable</li>
      <li>a <a href="../scheduler.html">Scheduler</a> on which this operator should operate</li>
     </ol>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
import fs from 'fs';

// Wrap fs.exists
var exists = Rx.Observable.bindCallback(fs.exists);

// Check if file.txt exists
var source = exists('file.txt');

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: true
Completed</pre></div>
     <p>
      There is also a <code>bindNodeCallback</code> operator, which is specialized for the types
      of callback functions found in Node.js.
     </p><p>
      This operator takes two additional, optional parameters:
     </p>
     <ol start="2">
      <li>a tranforming function that takes the return value of the callback function as input and returns an item to be emitted by the resulting Observable</li>
      <li>a <a href="../scheduler.html">Scheduler</a> on which this operator should operate</li>
     </ol>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
import fs from 'fs';

// Wrap fs.exists
var rename = Rx.Observable.bindNodeCallback(fs.rename);

// Rename file which returns no parameters except an error
var source = rename('file1.txt', 'file2.txt');

var subscription = source.subscribe(
  () => console.log('Next: success!'),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: success!
Completed</pre></div>
     </figcaption>
    </figure>
    <figure class="variant">
     <img src="images/fromEvent.png" style="width:100%;" alt="fromEvent" />
     <figcaption><p>
      The <code>fromEvent</code> operator takes an &ldquo;element&rdquo; and an event name as
      parameters, and it then listens for events of that name taking place on that element. It
      returns an Observable that emits those events. An &ldquo;element&rdquo; may be a simple
      <abbr title="document-object model">DOM</abbr> element, or a NodeList, jQuery element,
      Zepto Element, Angular element, Ember.js element, or EventEmitter.
     </p><p>
      This operator also takes an optional third parameter: a function that accepts the arguments
      from the event handler as parameters and returns an item to be emitted by the resulting
      Observable in place of the event.
     </p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
// using a jQuery element
var input = $('#input');

var source = Rx.Observable.fromEvent(input, 'click');

var subscription = source.subscribe(
  (x) => console.log('Next: Clicked!'),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);

input.trigger('click');</pre></div>
     <div class="output"><pre>
Next: Clicked!</pre></div>
     <div class="code javascript"><pre>
// using a Node.js EventEmitter and the optional third parameter
import {EventEmitter} from 'events';

var eventEmitter = new EventEmitter();

var source = Rx.Observable.fromEvent(eventEmitter, 'data',
  (first, second) => {
    return { foo: first, bar: second };
  }
);

var subscription = source.subscribe(
  (x) => console.log('Next: foo -' + x.foo + ', bar -' + x.bar),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);

eventEmitter.emit('data', 'baz', 'quux');</pre></div>
     <div class="output"><pre>
Next: foo - baz, bar - quux</pre></div>
     <p>
      The <code>fromEventPattern</code> operator is similar to <code>fromEvent</code>, except that
      instead of taking an element and an event name as parameters, it takes two functions as
      parameters. The first function attaches an event listener to a variety of events on a variety
      of elements; the second function removes this set of listeners. In this way you can establish
      a single Observable that emits items representing a variety of events and a variety of target
      elements.
     </p>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var input = $('#input');

var source = Rx.Observable.fromEventPattern(
  function add (h) {
    input.bind('click', h);
  },
  function remove (h) {
    input.unbind('click', h);
  }
);

var subscription = source.subscribe(
  (x) => console.log('Next: Clicked!'); },
  (err) => console.log('Error: ' + err); },
  () => console.log('Completed'); }
);

input.trigger('click');</pre></div>
     <div class="output"><pre>
Next: Clicked!</pre></div>
    </figcaption></figure>
    <figure class="variant">
     <img src="images/of.png" style="width:100%;" alt="of" />
     <figcaption><p>
      The <code>of</code> operator accepts a number of items as parameters, and returns an
      Observable that emits each of these parameters, in order, as its emitted sequence.
     </p><p>
      If the last parameter given to this operator is a Scheduler type, then it will be used as
      the Scheduler, instead of as an item to be emitted.
     </p>
     <ol start="2">
      <li>a <a href="../scheduler.html">Scheduler</a> on which this operator should operate</li>
     </ol>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var source = Rx.Observable.of(1, 2, 3);

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (err) => console.log('Error: ' + err),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: 1
Next: 2
Next: 3
Completed</pre></div>
     </figcaption>
    </figure>
    <p>
     There is also a <code>fromPromise</code> operator that converts a Promise into an Observable,
     converting its <code>resolve</code> calls into <code>next</code> notifications, and its
     <code>reject</code> calls into <code>error</code> notifications.
    </p>
    <h4>Sample Code</h4>
    <div class="code javascript"><pre>
var promise = new Promise(function (resolve, reject) {
   resolve(42);
});

var source = Rx.Observable.fromPromise(promise);

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (e) => console.log('Error: ' + e),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Next: 42:
Completed</pre></div>
    <div class="code javascript"><pre>
var promise = new Promise(function (resolve, reject) {
   reject(new Error('reason'));
});

var source = Rx.Observable.fromPromise(promise);

var subscription = source.subscribe(
  (x) => console.log('Next: ' + x),
  (e) => console.log('Error: ' + e),
  () => console.log('Completed')
);</pre></div>
     <div class="output"><pre>
Error: Error: reject</pre></div>
  {% endlang_operator %}

  {% lang_operator RxKotlin asObservable from %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator Rx.NET AsObservable FromAsyncPattern FromEvent FromEventPattern ToObservable %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxPY from_array from_callback from_future from_iterable from_list from_marbles of %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator Rx.rb of_array of_enumerable of_enumerator %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxScala from items %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxSwift from toObservable %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

</div>
