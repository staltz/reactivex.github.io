---
layout: documentation
title: ReactiveX - Window operator
id: window
---

<ol class="breadcrumb">
  <li><a href="{{ site.url }}/documentation/operators.html">Operators</a></li>
  <li><a href="{{ site.url }}/documentation/operators.html#transforming">Transforming</a></li>
  <li class="active">Window</li>
</ol>

   <h1>Window</h1>
   <h3>periodically subdivide items from an Observable into Observable windows and emit these
       windows rather than emitting the items one at a time</h3>
   <figure>
    <img src="images/window.C.png" style="width:100%;" alt="Window" />
    <figcaption><p>
     <span class="operator">Window</span> is similar to
     <a href="buffer.html"><span class="operator">Buffer</span></a>, but rather than emitting packets
     of items from the source Observable, it emits Observables, each one of which emits a subset of
     items from the source Observable and then terminates with an <code>onCompleted</code>
     notification.
    </p><p>
     Like <span class="operator">Buffer</span>, <span class="operator">Window</span> has many
     varieties, each with its own way of subdividing the original Observable into the resulting
     Observable emissions, each one of which contains a &ldquo;window&rdquo; onto the original
     emitted items. In the terminology of the <span class="operator">Window</span> operator, when a
     window &ldquo;opens,&rdquo; this means that a new Observable is emitted and that Observable will
     begin emitting items emitted by the source Observable. When a window &ldquo;closes,&rdquo; this
     means that the emitted Observable stops emitting items from the source Observable and terminates
     with an <code>onCompleted</code> notification to its observers.
    </p></figcaption>
   </figure>

   <h4>See Also</h4>
   <ul>
    <li><a href="buffer.html"><span class="operator">Buffer</span></a></li>
    <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#Window"><cite>Introduction to Rx</cite>: Window</a></li>
    <li><a href="http://rxwiki.wikidot.com/101samples#toc38"><cite>101 Rx Samples</cite>: Window</a></li>
   </ul>

   <h2>Language-Specific Information:</h2>
<div class="panel-group operators-by-language" id="accordion" role="tablist" aria-multiselectable="true">

  {% lang_operator RxClojure partition-all %}
     <p>
      RxClojure implements this operator as <code>partition-all</code>:
     </p>
     <figure>
      <img src="images/partition-all.png" style="width:100%;" alt="partition-all" />
      <figcaption><p>
       <code>partition-all</code> opens its first window immediately. It opens a new window
       beginning with every <code>step</code> item from the source Observable (so, for example, if
       <code>step</code> is 3, then it opens a new window starting with every third item). It closes
       each window when that window has emitted <code>n</code> items or if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable. If
       <code>step&nbsp;=&nbsp;n</code> (which is the default if you omit the <code>step</code>
       parameter) then the window size is the same as the step size and there will be a one-to-one
       correspondence between the items emitted by the source Observable and the items emitted by
       the collection of window Observables. If <code>step&nbsp;&lt;&nbsp;n</code> the windows will
       overlap by <code>n&nbsp;&minus;&nbsp;step</code> items; if <code>step&nbsp;&gt;&nbsp;n</code>
       the windows will drop <code>step&nbsp;&minus;&nbsp;n</code> items from the source Observable
       between every window.
      </p></figcaption>
     </figure>
  {% endlang_operator %}

  {% lang_operator RxCpp window window_with_time window_with_time_or_count %}
     <p>
      RxCpp implements this operator as two variants of <code>window</code>, two variants of
      <code>window_with_time</code>, and as <code>window_with_time_or_count</code>:
     </p>
     <h4><code>window(count)</code></h4>
     <figure>
      <img src="images/window3.png" style="width:100%;" alt="window(count)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one whenever the current window has emitted
       <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>window</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>window(count, skip)</code></h4>
     <figure>
      <img src="images/window4.png" style="width:100%;" alt="window(count, skip)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It opens a new window
       beginning with every <code>skip</code> item from the source Observable (so, for example, if
       <code>skip</code> is 3, then it opens a new window starting with every third item). It closes
       each window when that window has emitted <code>count</code> items or if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable. If
       <code>skip&nbsp;=&nbsp;count</code> then this behaves the same as
       <code>window(source,&nbsp;count)</code>; if <code>skip&nbsp;&lt;&nbsp;count</code> this will
       emit windows that overlap by <code>count&nbsp;&minus;&nbsp;skip</code> items; if
       <code>skip&nbsp;&gt;&nbsp;count</code> this will emit windows that drop
       <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable between every
       window.
      </p></figcaption>
     </figure>
     <h4><code>window_with_time(period</code>[<code>, coordination</code>]<code>)</code></h4>
     <figure>
      <img src="images/window_with_time5.png" style="width:100%;" alt="window_with_time(period[,coordination])" />
      <figcaption><p>
       This variant of <code>window_with_time</code> opens its first window immediately. It closes
       the currently open window and opens another one every <code>period</code> of time (a
       Duration, optionally computed by a given Coordination). It will also close the currently open
       window if it receives an <code>onCompleted</code> or <code>onError</code> notification from
       the source Observable. This variant of <code>window_with_time</code> emits a series of
       non-overlapping windows whose collective emissions correspond one-to-one with those of the
       source Observable.
      </p></figcaption>
     </figure>
     <h4><code>window_with_time(period, skip</code>[<code>, coordination</code>]<code>)</code></h4>
     <figure>
      <img src="images/window_with_time7.png" style="width:100%;" alt="window_with_time(period,skip[,coordination])" />
      <figcaption><p>
       This variant of <code>window_with_time</code> opens its first window immediately. It closes
       the currently open window after <code>period</code> amount of time has passed since it was
       opened, and opens a new window after <code>skip</code> amount of time has passed since the
       previous window was opened (both times are Durations, optionally computed by a given
       Coordination). It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>window_with_time</code> may emit windows that overlap or that have
       gaps, depending on whether <code>skip</code> is less than or greater than
       <code>period</code>.
      </p></figcaption>
     </figure>
     <h4><code>window_with_time_or_count(period, count</code>[<code>, coordination</code>]<code>)</code></h4>
     <figure>
      <img src="images/window_with_time_or_count.png" style="width:100%;" alt="window_with_time_or_count(period,count[,coordination])" />
      <figcaption><p>
       <code>window_with_time_or_count</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>period</code> of time (optionally
       computed by a given Coordination) or whenever the currently open window has emitted
       <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       <code>window_with_time_or_count</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
  {% endlang_operator %}

  {% lang_operator RxGroovy window %}
     <p>
      There are several varieties of <span class="operator">Window</span> in RxGroovy.
     </p>
     <h4><code>window(closingSelector)</code></h4>
     <figure>
      <img src="images/window1.png" style="width:100%;" alt="window(closingSelector)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one each time it observes an object emitted
       by the Observable that is returned from <code>closingSelector</code>. In this way, this
       variant of <code>window</code> emits a series of non-overlapping windows whose collective
       emissions correspond one-to-one with those of the source Observable.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0)"><code>window(Func0)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(windowOpenings, closingSelector)</code></h4>
     <figure>
      <img src="images/window2.png" style="width:100%;" alt="window(windowOpenings, closingSelector)" />
      <figcaption><p>
       This variant of <code>window</code> opens a window whenever it observes the
       <code>windowOpenings</code> Observable emit an <code>Opening</code> object and at the same
       time calls <code>closingSelector</code> to generate a closing Observable associated with that
       window. When that closing Observable emits an object, <code>window</code> closes that window.
       Since the closing of currently open windows and the opening of new windows are activities
       that are regulated by independent Observables, this variant of <code>window</code> may create
       windows that overlap (duplicating items from the source Observable) or that leave gaps
       (discarding items from the source Observable).
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.Observable,%20rx.functions.Func1)"><code>window(Observable,Func1)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(count)</code></h4>
     <figure>
      <img src="images/window3.png" style="width:100%;" alt="window(count)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one whenever the current window has emitted
       <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>window</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int)"><code>window(int)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(count, skip)</code></h4>
     <figure>
      <img src="images/window4.png" style="width:100%;" alt="window(count, skip)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It opens a new window
       beginning with every <code>skip</code> item from the source Observable (so, for example, if
       <code>skip</code> is 3, then it opens a new window starting with every third item). It closes
       each window when that window has emitted <code>count</code> items or if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable. If
       <code>skip&nbsp;=&nbsp;count</code> then this behaves the same as
       <code>window(source,&nbsp;count)</code>; if <code>skip&nbsp;&lt;&nbsp;count</code> this will
       emit windows that overlap by <code>count&nbsp;&minus;&nbsp;skip</code> items; if
       <code>skip&nbsp;&gt;&nbsp;count</code> this will emit windows that drop
       <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable between every
       window.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int,%20int)"><code>window(int,int)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(timespan, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window5.png" style="width:100%;" alt="window(timespan, unit[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> period of time
       (measured in <code>unit</code>, and optionally on a particular
       <a href="../scheduler.html"><code>Scheduler</code></a>). It
       will also close the currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable. This variant of
       <code>window</code> emits a series of non-overlapping windows whose collective emissions
       correspond one-to-one with those of the source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit)"><code>window(long,TimeUnit)</code></a></li>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>window(long,TimeUnit,Scheduler)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window6.png" style="width:100%;" alt="window(timespan, unit, count[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> period of time
       (measured in <code>unit</code>, and optionally on a particular
       <a href="../scheduler.html"><code>Scheduler</code></a>) or
       whenever the currently open window has emitted <code>count</code> items. It will also close
       the currently open window if it receives an <code>onCompleted</code> or <code>onError</code>
       notification from the source Observable. This variant of <code>window</code> emits a series
       of non-overlapping windows whose collective emissions correspond one-to-one with those of the
       source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int)"><code>window(long,TimeUnit,int)</code></a></li>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)"><code>window(long,TimeUnit,int,Scheduler)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window7.png" style="width:100%;" alt="window(timespan, timeshift, unit[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately, and thereafter opens
       a new window every <code>timeshift</code> period of time (measured in <code>unit</code>, and
       optionally on a particular <a href="../scheduler.html"><code>Scheduler</code></a>). It closes a
       currently open window after <code>timespan</code> period of time has passed since that window was
       opened. It will also close any currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable. Depending on how you set
       <code>timespan</code> and <code>timeshift</code> the windows that result from this operation
       may overlap or may have gaps.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit)"><code>window(long,long,TimeUnit)</code></a></li>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>window(long,long,TimeUnit,Scheduler)</code></a></li>
      </ul></figcaption>
     </figure>
    <p>
     You can use the <span class="operator">Window</span> operator to implement backpressure (that
     is, to cope with an Observable that may produce items too quickly for its observer to consume).
    </p>
    <figure class="variant">
     <img src="images/bp.window1.png" style="width:100%;" alt="Window as a backpressure strategy" />
     <figcaption><p>
      Window can reduce a sequence of many items to a sequence of fewer windows-of-items, making
      them more manageable. You could, for example, emit a window of items from a bursty Observable
      periodically, at a regular interval of time.
     </p>
     <h4>Sample Code</h4>
     <div class="code groovy"><pre>
Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(500, TimeUnit.MILLISECONDS);</pre></div></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/bp.window2.png" style="width:100%;" alt="Window as a backpressure strategy" />
     <figcaption><p>
      Or you could choose to emit a new window of items for every <i>n</i> items emitted by the
      bursty Observable.
     </p>
     <h4>Sample Code</h4>
     <div class="code groovy"><pre>
Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(5);</pre></div>
     </figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJava window %}
     <p>
      There are several varieties of <span class="operator">Window</span> in RxJava.
     </p>
     <h4><code>window(closingSelector)</code></h4>
     <figure>
      <img src="images/window1.png" style="width:100%;" alt="window(closingSelector)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one each time it observes an object emitted
       by the Observable that is returned from <code>closingSelector</code>. In this way, this
       variant of <code>window</code> emits a series of non-overlapping windows whose collective
       emissions correspond one-to-one with those of the source Observable.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0)"><code>window(Func0)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(windowOpenings, closingSelector)</code></h4>
     <figure>
      <img src="images/window2.png" style="width:100%;" alt="window(windowOpenings, closingSelector)" />
      <figcaption><p>
       This variant of <code>window</code> opens a window whenever it observes the
       <code>windowOpenings</code> Observable emit an <code>Opening</code> object and at the same
       time calls <code>closingSelector</code> to generate a closing Observable associated with that
       window. When that closing Observable emits an object, <code>window</code> closes that window.
       Since the closing of currently open windows and the opening of new windows are activities
       that are regulated by independent Observables, this variant of <code>window</code> may create
       windows that overlap (duplicating items from the source Observable) or that leave gaps
       (discarding items from the source Observable).
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.Observable,%20rx.functions.Func1)"><code>window(Observable,Func1)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(count)</code></h4>
     <figure>
      <img src="images/window3.png" style="width:100%;" alt="window(count)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one whenever the current window has emitted
       <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>window</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int)"><code>window(int)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(count, skip)</code></h4>
     <figure>
      <img src="images/window4.png" style="width:100%;" alt="window(count, skip)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It opens a new window
       beginning with every <code>skip</code> item from the source Observable (so, for example, if
       <code>skip</code> is 3, then it opens a new window starting with every third item). It closes
       each window when that window has emitted <code>count</code> items or if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable. If
       <code>skip&nbsp;=&nbsp;count</code> then this behaves the same as
       <code>window(source,&nbsp;count)</code>; if <code>skip&nbsp;&lt;&nbsp;count</code> this will
       emit windows that overlap by <code>count&nbsp;&minus;&nbsp;skip</code> items; if
       <code>skip&nbsp;&gt;&nbsp;count</code> this will emit windows that drop
       <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable between every
       window.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int,%20int)"><code>window(int,int)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(timespan, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window5.png" style="width:100%;" alt="window(timespan, unit[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> period of time
       (measured in <code>unit</code>, and optionally on a particular
       <a href="../scheduler.html"><code>Scheduler</code></a>). It
       will also close the currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable. This variant of
       <code>window</code> emits a series of non-overlapping windows whose collective emissions
       correspond one-to-one with those of the source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit)"><code>window(long,TimeUnit)</code></a></li>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>window(long,TimeUnit,Scheduler)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window6.png" style="width:100%;" alt="window(timespan, unit, count[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> period of time
       (measured in <code>unit</code>, and optionally on a particular
       <a href="../scheduler.html"><code>Scheduler</code></a>) or
       whenever the currently open window has emitted <code>count</code> items. It will also close
       the currently open window if it receives an <code>onCompleted</code> or <code>onError</code>
       notification from the source Observable. This variant of <code>window</code> emits a series
       of non-overlapping windows whose collective emissions correspond one-to-one with those of the
       source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int)"><code>window(long,TimeUnit,int)</code></a></li>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)"><code>window(long,TimeUnit,int,Scheduler)</code></a></li>
      </ul></figcaption>
     </figure>
     <h4><code>window(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window7.png" style="width:100%;" alt="window(timespan, timeshift, unit[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately, and thereafter opens
       a new window every <code>timeshift</code> period of time (measured in <code>unit</code>, and
       optionally on a particular <a href="../scheduler.html"><code>Scheduler</code></a>). It closes a
       currently open window after <code>timespan</code> period of time has passed since that window was
       opened. It will also close any currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable. Depending on how you set
       <code>timespan</code> and <code>timeshift</code> the windows that result from this operation
       may overlap or may have gaps.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p>
      <ul>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit)"><code>window(long,long,TimeUnit)</code></a></li>
       <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>window(long,long,TimeUnit,Scheduler)</code></a></li>
      </ul></figcaption>
     </figure>
    <p>
     You can use the <span class="operator">Window</span> operator to implement backpressure (that
     is, to cope with an Observable that may produce items too quickly for its observer to consume).
    </p>
    <figure class="variant">
     <img src="images/bp.window1.png" style="width:100%;" alt="Window as a backpressure strategy" />
     <figcaption><p>
      Window can reduce a sequence of many items to a sequence of fewer windows-of-items, making
      them more manageable. You could, for example, emit a window of items from a bursty Observable
      periodically, at a regular interval of time.
     </p>
     <h4>Sample Code</h4>
     <div class="code java"><pre>
Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(500, TimeUnit.MILLISECONDS);</pre></div></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/bp.window2.png" style="width:100%;" alt="Window as a backpressure strategy" />
     <figcaption><p>
      Or you could choose to emit a new window of items for every <i>n</i> items emitted by the
      bursty Observable.
     </p>
     <h4>Sample Code</h4>
     <div class="code java"><pre>
Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(5);</pre></div>
     </figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJS window windowCount windowTime windowToggle windowWhen %}
    <p>
      RxJS has five <span class="operator">Window</span> operators &mdash; <code>window</code>,
      <code>windowCount</code>, <code>windowTime</code>, <code>windowToggle</code> and
      <code>windowWhen</code> &mdash; each of which may have variants that have different
      ways of governing which source Observable items are emitted as part of which windows.
    </p>
    <h4><code>window(closingNotifier)</code></h4>
    <figure>
      <img src="images/window8.b.png" style="width:100%;" alt="window(closingNotifier)" />
      <figcaption>
        <p>
          <code>window(closingNotifier)</code> closes the current window and opens a new window whenever the monitored Observable <code>closingNotifier</code> emits. The first window is opened immediately when the operator enters into effect.
        </p>
      </figcaption>
    </figure>
   <h4><code>windowWhen(closingSelector)</code></h4>
   <figure class="variant">
    <img src="images/window1.net.png" style="width:100%;" alt="window(closingSelector)" />
    <figcaption>
     <p>
       When it subscribes to the source Observable, <code>windowWhen(closingSelector)</code> opens a new window Observable and it also calls the <code>closingSelector</code> function to generate a second Observable, the "closings" Observable. When closings Observable emits an item, <code>windowWhen</code> closes the current window and and repeats this process: beginning a new window and calling <code>closingSelector</code> to create a new closings Observable to monitor. It will do this until the source Observable terminates.</p>
    </figcaption>
   </figure>
   <h4><code>windowToggle(openings, closingSelector)</code></h4>
   <figure class="variant">
    <img src="images/window2.net.png" style="width:100%;" alt="windowToggle(openings, closingSelector)" />
    <figcaption>
     <p>
       <code>windowToggle(openings,&#8239;closingSelector)</code> monitors an Observable,
        <code>openings</code>, that emits <code>WindowOpening</code> objects. Each time it
        observes such an emitted item, it creates a new window to begin relaying items
        emitted by the source Observable and it passes the <code>openings</code>
        Observable into the <code>closingSelector</code> function. That function returns a
        closings Observable. <code>windowToggle</code> monitors that Observable and when it
        detects an emitted item from it, it closes the current window and begins a new one.</p>
    </figcaption>
   </figure>
   <h4><code>windowCount(count)</code></h4>
   <figure class="variant">
    <img src="images/windowWithCount3.png" style="width:100%;" alt="windowCount(count)" />
    <figcaption>
      <p>
       <code>windowCount(count)</code> emits non-overlapping windows, each of which contains
        at most <code>count</code> items from the source Observable (the final emitted window may contain fewer than <code>count</code> items).
      </p>
    </figcaption>
   </figure>
   <h4><code>windowCount(count, skip)</code></h4>
   <figure class="variant">
    <img src="images/windowWithCount4.png" style="width:100%;" alt="windowCount(count,skip)" />
    <figcaption>
      <p>
        <code>windowCount(count,&#8239;skip)</code> creates a new window starting with the
        first emitted item from the source Observable, and a new one for every <code>skip</code> items thereafter, and emits on each window at most <code>count</code> items: the initial item and <code>count-1</code> subsequent ones. Depending on the values of <code>count</code> and <code>skip</code> these windows may overlap (multiple windows may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any window).
      </p>
    </figcaption>
   </figure>
   <h4><code>windowTime(timeSpan)</code></h4>
   <figure class="variant">
    <img src="images/windowWithTime5.png" style="width:100%;" alt="windowTime(timeSpan)" />
    <figcaption>
      <p>
        <code>windowTime(timeSpan)</code> starts a new window periodically, every <code>timeSpan</code> milliseconds, containing all items emitted by the source Observable since the window was opened or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>asap</code> scheduler.</p>
    </figcaption>
  </figure>
  <h4><code>windowTime(timeSpan, timeShift)</code></h4>
  <figure class="variant">
    <img src="images/windowWithTime7.png" style="width:100%;" alt="windowTime(timeSpan,timeShift)" />
    <figcaption>
      <p>
        <code>windowTime(timeSpan,&#8239;timeShift)</code> starts a new window every <code>timeShift</code> milliseconds, and emits on this window every item emitted
        by the source Observable from that time until <code>timeSpan</code> milliseconds has
        passed since the window&#8217;s creation. If <code>timeSpan</code> is longer than <code>timeShift</code>, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the timespan; by default this variant uses the <code>asap</code> scheduler.</p>
    </figcaption>
  </figure>
  {% endlang_operator %}

  {% lang_operator RxKotlin window %}
     <p>
      There are several varieties of <span class="operator">Window</span> in RxKotlin.
     </p>
     <h4><code>window(closingSelector)</code></h4>
     <figure>
      <img src="images/window1.png" style="width:100%;" alt="window(closingSelector)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one each time it observes an object emitted
       by the Observable that is returned from <code>closingSelector</code>. In this way, this
       variant of <code>window</code> emits a series of non-overlapping windows whose collective
       emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>window(windowOpenings, closingSelector)</code></h4>
     <figure>
      <img src="images/window2.png" style="width:100%;" alt="window(windowOpenings, closingSelector)" />
      <figcaption><p>
       This variant of <code>window</code> opens a window whenever it observes the
       <code>windowOpenings</code> Observable emit an <code>Opening</code> object and at the same
       time calls <code>closingSelector</code> to generate a closing Observable associated with that
       window. When that closing Observable emits an object, <code>window</code> closes that window.
       Since the closing of currently open windows and the opening of new windows are activities
       that are regulated by independent Observables, this variant of <code>window</code> may create
       windows that overlap (duplicating items from the source Observable) or that leave gaps
       (discarding items from the source Observable).
      </p></figcaption>
     </figure>
     <h4><code>window(count)</code></h4>
     <figure>
      <img src="images/window3.png" style="width:100%;" alt="window(count)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one whenever the current window has emitted
       <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>window</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>window(count, skip)</code></h4>
     <figure>
      <img src="images/window4.png" style="width:100%;" alt="window(count, skip)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It opens a new window
       beginning with every <code>skip</code> item from the source Observable (so, for example, if
       <code>skip</code> is 3, then it opens a new window starting with every third item). It closes
       each window when that window has emitted <code>count</code> items or if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable. If
       <code>skip&nbsp;=&nbsp;count</code> then this behaves the same as
       <code>window(source,&nbsp;count)</code>; if <code>skip&nbsp;&lt;&nbsp;count</code> this will
       emit windows that overlap by <code>count&nbsp;&minus;&nbsp;skip</code> items; if
       <code>skip&nbsp;&gt;&nbsp;count</code> this will emit windows that drop
       <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable between every
       window.
      </p></figcaption>
     </figure>
     <h4><code>window(timespan, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window5.png" style="width:100%;" alt="window(timespan, unit[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> period of time
       (measured in <code>unit</code>, and optionally on a particular
       <a href="../scheduler.html"><code>Scheduler</code></a>). It
       will also close the currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable. This variant of
       <code>window</code> emits a series of non-overlapping windows whose collective emissions
       correspond one-to-one with those of the source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p></figcaption>
     </figure>
     <h4><code>window(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window6.png" style="width:100%;" alt="window(timespan, unit, count[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> period of time
       (measured in <code>unit</code>, and optionally on a particular
       <a href="../scheduler.html"><code>Scheduler</code></a>) or
       whenever the currently open window has emitted <code>count</code> items. It will also close
       the currently open window if it receives an <code>onCompleted</code> or <code>onError</code>
       notification from the source Observable. This variant of <code>window</code> emits a series
       of non-overlapping windows whose collective emissions correspond one-to-one with those of the
       source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p></figcaption>
     </figure>
     <h4><code>window(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window7.png" style="width:100%;" alt="window(timespan, timeshift, unit[, scheduler])" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately, and thereafter opens
       a new window every <code>timeshift</code> period of time (measured in <code>unit</code>, and
       optionally on a particular <a href="../scheduler.html"><code>Scheduler</code></a>). It closes a currently
       open window after <code>timespan</code> period of time has passed since that window was opened. It will
       also close any currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable. Depending on how you set
       <code>timespan</code> and <code>timeshift</code> the windows that result from this operation
       may overlap or may have gaps.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window</code> uses the 
       <code>computation</code> Scheduler for its timer by default.
      </p></figcaption>
     </figure>
  {% endlang_operator %}

  {% lang_operator Rx.NET Window %}
     <p>
      There are several variants of the <span class="operator">Window</span> operator in Rx.NET.
     </p>
     <h4><code>Window(windowClosingSelector)</code></h4>
     <figure>
      <img src="images/window1.net.png" style="width:100%;" alt="window(windowClosingSelector)" />
      <figcaption><p>
       This variant of <code>Window</code> opens its first window immediately and calls the
       <code>windowClosingSelector</code> function to obtain a second Observable. Whenever this second
       Observable emits a <code>TWindowClosing</code> object, <code>Window</code> closes the
       currently open window, and immediately opens a new one. It repeats this process until either
       Observable terminates. In this way, this variant of <code>Window</code> emits a series of
       non-overlapping windows whose collective emissions correspond one-to-one with those of the
       source Observable, until the closing selector observable terminates.
      </p></figcaption>
     </figure>
     <h4><code>Window(count)</code></h4>
     <figure>
      <img src="images/window3.net.png" style="width:100%;" alt="window(count)" />
      <figcaption><p>
       This variant of <code>Window</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one whenever the current window has emitted
       <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>Window</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>Window(timeSpan</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window5.net.png" style="width:100%;" alt="window(timeSpan)" />
      <figcaption><p>
       This variant of <code>Window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> period of time
       (in the form of a <code>TimeSpan</code> object, and optionally on a particular
       <a href="../scheduler.html"><code>IScheduler</code></a>). It will also close the currently open window if
       it receives an <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>Window</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>Window(count,skip)</code></h4>
     <figure>
      <img src="images/window4.net.png" style="width:100%;" alt="window(count,skip)" />
      <figcaption><p>
       This variant of <code>Window</code> opens its first window immediately. It opens a new window
       beginning with every <code>skip</code> item from the source Observable (so, for example, if
       <code>skip</code> is 3, then it opens a new window starting with every third item). It closes
       each window when that window has emitted <code>count</code> items or if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable. If
       <code>skip&nbsp;=&nbsp;count</code> then this behaves the same as
       <code>Window(source,&nbsp;count)</code>; if <code>skip&nbsp;&lt;&nbsp;count</code> this will
       emit windows that overlap by <code>count&nbsp;&minus;&nbsp;skip</code> items; if
       <code>skip&nbsp;&gt;&nbsp;count</code> this will emit windows that drop
       <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable between every
       window.
      </p></figcaption>
     </figure>
     <h4><code>Window(windowOpenings,windowClosingSelector)</code></h4>
     <figure>
      <img src="images/window2.net.png" style="width:100%;" alt="window(windowOpenings,windowClosingSelector)" />
      <figcaption><p>
       This variant of <code>Window</code> opens a window whenever it observes the
       <code>windowOpenings</code> Observable emit an <code>TWindowOpening</code> object and at the
       same time calls the <code>windowClosingSelector</code>, passing it that
       <code>TWindowOpening</code> object, to generate a closing Observable associated with that
       window. When that closing Observable emits a <code>TWindowClosing</code> object,
       <code>Window</code> closes the associated window. Since the closing of currently open windows
       and the opening of new windows are activities that are regulated by independent Observables,
       this variant of <code>Window</code> may create windows that overlap (duplicating items from
       the source Observable) or that leave gaps (discarding items from the source Observable).
      </p></figcaption>
     </figure>
     <h4><code>Window(timeSpan,count</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window6.net.png" style="width:100%;" alt="window(timeSpan,count)" />
      <figcaption><p>
       This variant of <code>Window</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timeSpan</code> period of time
       (in the form of a <code>TimeSpan</code> object, and optionally on a particular
       <a href="../scheduler.html"><code>IScheduler</code></a>) or whenever the currently open window has
       emitted <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>window</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>Window(timeSpan,timeShift</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window7.net.png" style="width:100%;" alt="window(timeSpan,timeShift)" />
      <figcaption><p>
       This variant of <code>Window</code> opens its first window immediately, and thereafter opens
       a new window every <code>timeShift</code> period of time (in the form of a
       <code>TimeSpan</code> object, and optionally on a particular
       <a href="../scheduler.html"><code>IScheduler</code></a>). It
       closes a currently open window after <code>timeSpan</code> period of time has passed since
       that window was opened. It will also close any currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       Depending on how you set <code>timeSpan</code> and <code>timeShift</code> the windows that
       result from this operation may overlap or may have gaps.
      </p></figcaption>
     </figure>
  {% endlang_operator %}

  {% lang_operator RxPY window window_with_count window_with_time window_with_time_or_count %}
     <p>
      RxPY implements this operator with several variants of four different functions.
     </p>
     <h4><code>window(window_closing_selector)</code></h4>
     <figure>
      <img src="images/window1.net.png" style="width:100%;" alt="window(window_closing_selector)" />
      <figcaption><p>
       This variant of <code>window</code> opens its first window immediately and calls the
       <code>closing_selector</code> function to obtain a second Observable. When this second
       Observable emits an item, <code>window</code> closes the currently open window, immediately
       opens a new one, and again calls the <code>closing_selector</code> function to obtain a fresh
       Observable. It repeats this process until the source Observable terminates. In this way, this
       variant of <code>window</code> emits a series of non-overlapping windows whose collective
       emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>window(window_openings,window_closing_selector)</code></h4>
     <figure>
      <img src="images/window2.png" style="width:100%;" alt="window(window_openings,window_closing_selector)" />
      <figcaption><p>
       This variant of <code>window</code> opens a window whenever it observes the
       <code>window_openings</code> Observable emit an item, and at the same time calls
       <code>closing_selector</code> to generate a closing Observable associated with that window.
       When that closing Observable emits an object, <code>window</code> closes that window.
       Since the closing of currently open windows and the opening of new windows are activities
       that are regulated by independent Observables, this variant of <code>window</code> may create
       windows that overlap (duplicating items from the source Observable) or that leave gaps
       (discarding items from the source Observable).
      </p></figcaption>
     </figure>
     <h4><code>window(window_openings)</code></h4>
     <figure>
      <img src="images/window8.png" style="width:100%;" alt="window(window_openings)" />
      <figcaption><p>
       This variant of <code>window</code> takes a second Observable as a parameter. Whenever this
       second Observable emits an item, <code>window</code> closes the current Observable window
       (if any) and opens a new one.
      </p></figcaption>
     </figure>
     <h4><code>window_with_count(count)</code></h4>
     <figure>
      <img src="images/window_with_count3.png" style="width:100%;" alt="window_with_count(count)" />
      <figcaption><p>
       This variant of <code>window_with_count</code> opens its first window immediately. It closes
       the currently open window and immediately opens a new one whenever the current window has
       emitted <code>count</code> items. It will also close the currently open window if it receives
       an <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       This variant of <code>window_with_count</code> emits a series of non-overlapping windows
       whose collective emissions correspond one-to-one with those of the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>window_with_count(count,skip)</code></h4>
     <figure>
      <img src="images/window_with_count4.png" style="width:100%;" alt="window_with_count(count,skip)" />
      <figcaption><p>
       This variant of <code>window_with_count</code> opens its first window immediately. It opens
       a new window beginning with every <code>skip</code> item from the source Observable (so, for
       example, if <code>skip</code> is 3, then it opens a new window starting with every third
       item). It closes each window when that window has emitted <code>count</code> items or if it
       receives an <code>onCompleted</code> or <code>onError</code> notification from the source
       Observable. If <code>skip&nbsp;=&nbsp;count</code> then this behaves the same as
       <code>window_with_count(count)</code>; if <code>skip&nbsp;&lt;&nbsp;count</code> this will
       emit windows that overlap by <code>count&nbsp;&minus;&nbsp;skip</code> items; if
       <code>skip&nbsp;&gt;&nbsp;count</code> this will emit windows that drop
       <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable between every
       window.
      </p></figcaption>
     </figure>
     <h4><code>window_with_time(timespan</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window_with_time5.py.png" style="width:100%;" alt="window_with_time(timespan)" />
      <figcaption><p>
      </p></figcaption>
     </figure>
     <h4><code>window_with_time(timespan,timeshift</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window_with_time7.py.png" style="width:100%;" alt="window_with_time(timespan,timeshift)" />
      <figcaption><p>
       This variant of <code>window_with_time</code> opens its first window immediately. It closes
       the currently open window and opens another one every <code>timespan</code> milliseconds (optionally
       measured on a particular <a href="../scheduler.html"><code>Scheduler</code></a>). It will also close the
       currently open window if it receives an <code>onCompleted</code> or <code>onError</code>
       notification from the source Observable. This variant of <code>window_with_time</code> emits
       a series of non-overlapping windows whose collective emissions correspond one-to-one with
       those of the source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window_with_time</code> uses the 
       <code>timeout</code> Scheduler for its timer by default.
      </p></figcaption>
     </figure>
     <h4><code>window_with_time_or_count(timespan,count</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/window_with_time_or_count.py.png" style="width:100%;" alt="window_with_time_or_count(timespan,count)" />
      <figcaption><p>
       <code>window_with_time_or_count</code> opens its first window immediately. It closes the
       currently open window and opens another one every <code>timespan</code> milliseconds (optionally measured
       on a particular <a href="../scheduler.html">Scheduler</a>) or whenever the currently open window has
       emitted <code>count</code> items. It will also close the currently open window if it receives
       an <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
       <code>window_with_time_or_count</code> emits a series of non-overlapping windows whose
       collective emissions correspond one-to-one with those of the source Observable.
      </p><p>
       If you do not specify a Scheduler, this variant of <code>window_with_time_or_count</code>
       uses the <code>timeout</code> Scheduler for its timer by default.
      </p></figcaption>
     </figure>
  {% endlang_operator %}

  {% lang_operator Rx.rb window_with_count %}
     <h4><code>window_with_count(count,skip)</code></h4>
     <figure>
      <img src="images/window_with_count4.png" style="width:100%;" alt="window_with_count(count,skip)" />
      <figcaption><p>
       Rx.rb implements this operator as <code>window_with_count</code>. It opens its first window
       immediately. It then opens a new window beginning with every <code>skip</code> item from the
       source Observable (so, for example, if <code>skip</code> is 3, then it opens a new window
       starting with every third item). It closes each window when that window has emitted
       <code>count</code> items or if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable. If
       <code>skip&nbsp;=&nbsp;count</code> then there is a one-to-one correspondence between the
       items emitted by the source Observable and those emitted by the window Observables; if
       <code>skip&nbsp;&lt;&nbsp;count</code> the windows will overlap by
       <code>count&nbsp;&minus;&nbsp;skip</code> items; if <code>skip&nbsp;&gt;&nbsp;count</code> the
       windows will drop <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable
       between every window.
      </p></figcaption>
     </figure>
  {% endlang_operator %}

  {% lang_operator RxScala sliding tumbling %}
     <p>
      RxScala implements this operator as <code>sliding</code> (creates windows that may overlap or
      have gaps) and <code>tumbling</code> (creates windows whose collective emissions match those
      of the source Observable one-to-one).
     </p>
     <h4><code>sliding(timespan,timeshift,count</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/sliding9.png" style="width:100%;" alt="sliding(timespan,timeshift,count)" />
      <figcaption><p>
       This variant of <code>sliding</code> opens its first window immediately, and thereafter opens
       a new window every <code>timeshift</code> period of time (in the form of a <code>Duration</code> object,
       and optionally on a particular <a href="../scheduler.html"><code>Scheduler</code></a>). It
       closes a currently open window after <code>timespan</code> period of time has passed since
       that window was opened or once <code>count</code> items have been emitted on that window. It
       will also close any currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>sliding(timespan,timeshift</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/sliding7.png" style="width:100%;" alt="sliding(timespan,timeshift)" />
      <figcaption><p>
       This variant of <code>sliding</code> opens its first window immediately, and thereafter opens
       a new window every <code>timeshift</code> period of time (in the form of a <code>Duration</code> object,
       and optionally on a particular <a href="../scheduler.html"><code>Scheduler</code></a>). It
       closes a currently open window after <code>timespan</code> period of time has passed since
       that window was opened. It will also close any currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>sliding(count,skip)</code></h4>
     <figure>
      <img src="images/sliding4.png" style="width:100%;" alt="sliding(count,skip)" />
      <figcaption><p>
       This variant of <code>sliding</code> opens its first window immediately. It opens a new
       window beginning with every <code>skip</code> item from the source Observable (so, for
       example, if <code>skip</code> is 3, then it opens a new window starting with every third
       item). It closes each window when that window has emitted <code>count</code> items or if it
       receives an <code>onCompleted</code> or <code>onError</code> notification from the source
       Observable. If <code>skip&nbsp;=&nbsp;count</code> then this behaves the same as
       <code>tumbling(count)</code>; if <code>skip&nbsp;&lt;&nbsp;count</code> this will
       emit windows that overlap by <code>count&nbsp;&minus;&nbsp;skip</code> items; if
       <code>skip&nbsp;&gt;&nbsp;count</code> this will emit windows that drop
       <code>skip&nbsp;&minus;&nbsp;count</code> items from the source Observable between every
       window.
      </p></figcaption>
     </figure>
     <h4><code>sliding(openings,closings)</code></h4>
     <figure>
      <img src="images/sliding2.png" style="width:100%;" alt="sliding(openings,closings)" />
      <figcaption><p>
       This variant of <code>sliding</code> opens a window whenever it observes the
       <code>openings</code> Observable emit an <code>Opening</code> object and at the same
       time calls <code>closings</code> to generate a closing Observable associated with that
       window. When that closing Observable emits an item, <code>sliding</code> closes that window.
      </p></figcaption>
     </figure>
     <h4><code>tumbling(timespan,count</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/tumbling6.png" style="width:100%;" alt="tumbling(timespan,count)" />
      <figcaption><p>
       This variant of <code>tumbling</code> opens its first window immediately. It closes the currently open
       window and opens another one every <code>timespan</code> period of time (a <code>Duration</code>,
       optionally measured on a particular <a href="../scheduler.html"><code>Scheduler</code></a>) or
       whenever the currently open window has emitted <code>count</code> items. It will also close
       the currently open window if it receives an <code>onCompleted</code> or <code>onError</code>
       notification from the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>tumbling(timespan</code>[<code>,scheduler</code>]<code>)</code></h4>
     <figure>
      <img src="images/tumbling5.png" style="width:100%;" alt="tumbling(timespan)" />
      <figcaption><p>
       This variant of <code>tumbling</code> opens its first window immediately. It closes the currently open
       window and opens another one every <code>timespan</code> period of time (a <code>Duration</code>,
       optionally measured on a particular <a href="../scheduler.html"><code>scheduler</code></a>). It
       will also close the currently open window if it receives an <code>onCompleted</code> or
       <code>onError</code> notification from the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>tumbling(count)</code></h4>
     <figure>
      <img src="images/tumbling3.png" style="width:100%;" alt="tumbling(count)" />
      <figcaption><p>
       This variant of <code>tumbling</code> opens its first window immediately. It closes the
       currently open window and immediately opens a new one whenever the current window has emitted
       <code>count</code> items. It will also close the currently open window if it receives an
       <code>onCompleted</code> or <code>onError</code> notification from the source Observable.
      </p></figcaption>
     </figure>
     <h4><code>tumbling(boundary)</code></h4>
     <figure>
      <img src="images/tumbling8.png" style="width:100%;" alt="tumbling(boundary)" />
      <figcaption><p>
       This variant of <code>tumbling</code> takes a second Observable as a parameter. Whenever this
       second Observable emits an item, <code>tumbling</code> closes the current Observable window
       (if any) and opens a new one.
      </p></figcaption>
     </figure>
  {% endlang_operator %}

  {% lang_operator RxSwift window %}
     <p>
      <span style="color:#ff0000">TBD</span>
     </p>
  {% endlang_operator %}

</div>
